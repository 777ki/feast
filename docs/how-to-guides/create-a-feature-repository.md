# Create a feature repository

We believe that the best way to keep track of your feature definitions is to manage them as code. To define features, you simply describe your feature and data source declarations in pure Python. Then Feast CLI can read Python files with feature definitions, parse the definitions and help you create and manage the infrastructure required to serve these features in production.

## What is a Feature Repository?

Feature Repository is nothing more than a collection of Python files containing feature declarations, and a config file with some Feast settings. Typically, Feast users store those files in a git repository, hence the name. Note, however, that Feast makes no hard assumptions about your source control repository structure and doesn't even require you to use git.

## Creating a Feature Repository

The easiest way to get started is to use `feast init` command:

```bash
$ mkdir my_feature_repo && cd my_feature_repo
$ feast init
Generated feature_store.yaml and example features in example_repo.py
Now try runing `feast apply` to apply, or `feast materialize` to sync data to the online store
```

You can see that all this does is create a python file with feature definitions, some sample data, and a Feast configuration for local development:

```bash
$ tree
.
├── data
│   └── driver_stats.parquet
├── example.py
└── feature_store.yaml

1 directory, 3 files
```

## What's Inside a Feature Repository

Feast configuration is stored in a file named `feature_store.yaml`. There are no restrictions on how Python feature definition files can be named, as long as they're valid Python module names \(so no dashes\). There could be multiple files as well.

If you take a look at `feature_store.yaml` you'll see something like this:

{% code title="feature\_store.yaml" %}
```yaml
project: robust_tortoise
metadata_store: data/metadata.db
provider: local
online_store:
    local:
        path: data/online_store.db
```
{% endcode %}

Here `project` is a unique identifier for the Feature Repository generated by `feast init`. You can also notice that this configuration file uses a "local" provider that is most useful for development, as all data is stored and served locally on your computer. Because we're using a Local provider, both metadata store and online feature store are just files on your local file system.

Now, if you open `example.py` you'll see some example Feature Views and Data Source definitions. The file is too large to quote here but you should see something like this when you open it:

```python
from feast import Entity, Feature, FeatureView, ValueType
from feast.data_source import FileSource

...

driver_hourly_stats = FileSource(
    ...
)

driver = Entity(...)

driver_hourly_stats_view = FeatureView(
    name="driver_hourly_stats",
    entities=["driver_id"],
    ...
)
```

The way to declare Feature Views and other objects in Feast Feature Repository is to simply write Python code to instantiate the objects, set the parameters and make sure to assign them to a top-level module variable.

Feast CLI will process all Python files from the Feature Repository as modules and find all top-level variables. You don't need to name Python files or variables in a certain way; just make sure there is a separate variable for each Feast object.



